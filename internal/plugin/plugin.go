package plugin

import (
	"fmt"
	"runtime"

	"github.com/dave/jennifer/jen"
	"github.com/spf13/pflag"
	"google.golang.org/protobuf/compiler/protogen"
)

const nexusPkg = "github.com/nexus-rpc/sdk-go/nexus"
const workerPkg = "go.temporal.io/sdk/worker"
const workflowPkg = "go.temporal.io/sdk/workflow"

var multiLineValues = jen.Options{
	Close:     "}",
	Multi:     true,
	Open:      "{",
	Separator: ",",
}

type Plugin struct {
	*protogen.Plugin
	version string
	commit  string
	flags   *pflag.FlagSet
}

func New(version, commit string) *Plugin {
	flags := pflag.NewFlagSet("plugin", pflag.ExitOnError)

	return &Plugin{
		version: version,
		flags:   flags,
	}
}

func (p *Plugin) Param(key, value string) error {
	return p.flags.Set(key, value)
}

func (p *Plugin) Run(plugin *protogen.Plugin) error {
	p.Plugin = plugin
	for _, file := range plugin.Files {
		if !file.Generate {
			continue
		}

		f := jen.NewFilePathName(string(file.GoImportPath), string(file.GoPackageName))
		p.genCodeGenerationHeader(f, file)

		for _, svc := range file.Services {
			p.genConsts(f, svc)
			p.genHandler(f, svc)
			p.genClient(f, svc)
		}

		if err := f.Render(p.Plugin.NewGeneratedFile("oms/v1/service_nexus_temporal.pb.go", file.GoImportPath)); err != nil {
			return fmt.Errorf("error rendering file: %w", err)
		}
		// if err := f.Render(p.Plugin.NewGeneratedFile(fmt.Sprintf("%s_nexus_temporal.pb.go", file.GeneratedFilenamePrefix), file.GoImportPath)); err != nil {
		// 	return fmt.Errorf("error rendering file: %w", err)
		// }
	}

	return nil
}

func (p *Plugin) genCodeGenerationHeader(f *jen.File, target *protogen.File) {
	f.PackageComment("Code generated by protoc-gen-go_nexus-temporal. DO NOT EDIT.")
	f.PackageComment("versions: ")
	f.PackageComment(fmt.Sprintf("    protoc-gen-go_nexus-temporal %s (%s)", p.version, p.commit))
	f.PackageComment(fmt.Sprintf("    go %s", runtime.Version()))
	compilerVersion := p.Plugin.Request.CompilerVersion
	if compilerVersion != nil {
		f.PackageComment(fmt.Sprintf("    protoc %s", compilerVersion.String()))
	} else {
		f.PackageComment("    protoc (unknown)")
	}

	f.PackageComment(fmt.Sprintf("source: %s", target.Desc.Path()))
}

func (p *Plugin) genConsts(f *jen.File, svc *protogen.Service) {
	svcNameConst := fmt.Sprintf("%sServiceName", svc.GoName)
	svcNameVal := string(svc.Desc.FullName())
	f.Commentf("%s defines the fully-qualified name for the %s service.", svcNameConst, svcNameVal)
	f.Const().Id(svcNameConst).Op("=").Lit(svcNameVal)

	for _, method := range svc.Methods {
		operationNameConst := fmt.Sprintf("%sOperationName", method.GoName)
		operationNameVal := method.GoName

		f.Commentf("%s defines the fully-qualified name for the %s operation.", operationNameConst, operationNameVal)
		f.Const().Id(operationNameConst).Op("=").Lit(operationNameVal)
	}
}

func (p *Plugin) genHandler(f *jen.File, svc *protogen.Service) {
	ifaceName := fmt.Sprintf("%sNexusServiceHandler", svc.GoName)

	var statements []jen.Code

	for _, method := range svc.Methods {
		st := jen.Id(method.GoName).Params(jen.Id("name").String()).Qual(nexusPkg, "Operation").Types(
			jen.Op("*").Qual(string(method.Input.GoIdent.GoImportPath), method.Input.GoIdent.GoName),
			jen.Op("*").Qual(string(method.Output.GoIdent.GoImportPath), method.Output.GoIdent.GoName),
		)
		statements = append(statements, st)
	}
	f.Type().Id(ifaceName).Interface(statements...)

	f.Func().Id(fmt.Sprintf("Register%s", ifaceName)).Params(
		jen.Id("r").Qual(workerPkg, "NexusServiceRegistry"),
		jen.Id("h").Id(ifaceName),
	).BlockFunc(func(g *jen.Group) {
		g.Id("svc").Op(":=").Qual(nexusPkg, "NewService").Call(jen.Id(fmt.Sprintf("%sServiceName", svc.GoName)))
		g.Id("svc").Dot("Register").CallFunc(func(g *jen.Group) {
			for _, method := range svc.Methods {
				operationNameConst := fmt.Sprintf("%sOperationName", method.GoName)
				g.Id("h").Dot(method.GoName).Call(jen.Id(operationNameConst)).Op(",")
			}
		})

		g.Id("r").Dot("RegisterNexusService").Call(jen.Id("svc"))
	})
}

func (p *Plugin) genClient(f *jen.File, svc *protogen.Service) {
	structName := fmt.Sprintf("%sNexusClient", svc.GoName)

	// 	f.Commentf("%s provides an internal %s implementation", implName, ifaceName)
	f.Type().
		Id(structName).
		StructFunc(func(g *jen.Group) {
			g.Id("client").Qual(workflowPkg, "NexusClient")
		})

	ctorName := fmt.Sprintf("New%sNexusClient", svc.GoName)
	f.Commentf("%s initializes a new %s", ctorName, structName)
	f.Func().
		Id(ctorName).
		ParamsFunc(func(g *jen.Group) {
			g.Id("endpoint").String()
		}).
		Op("*").Id(structName).
		BlockFunc(func(g *jen.Group) {
			g.ReturnFunc(func(g *jen.Group) {
				g.Op("&").Id(structName).CustomFunc(multiLineValues, func(g *jen.Group) {
					g.Id("client").Op(":").Qual(workflowPkg, "NewNexusClient").CallFunc(func(g *jen.Group) {
						g.Id("endpoint")
						g.Id(fmt.Sprintf("%sServiceName", svc.GoName))
					})
				})
			})
		})

	for _, method := range svc.Methods {
		executeMethodName := fmt.Sprintf("Execute%s", method.GoName)
		startMethodName := fmt.Sprintf("Start%s", method.GoName)
		futureName := fmt.Sprintf("%sFuture", method.GoName)
		operationNameConst := fmt.Sprintf("%sOperationName", method.GoName)

		f.Type().Id(futureName).StructFunc(func(g *jen.Group) {
			g.Qual(workflowPkg, "NexusOperationFuture")
		})

		f.Func().
			ParamsFunc(func(g *jen.Group) {
				g.Id("f").Op("*").Id(futureName)
			}).
			Id("GetTyped").
			ParamsFunc(func(g *jen.Group) {
				g.Id("ctx").Qual(workflowPkg, "Context")
			}).
			ParamsFunc(func(g *jen.Group) {
				// 		// if hasOutput {
				g.Op("*").Qual(string(method.Output.GoIdent.GoImportPath), method.Output.GoIdent.GoName)
				// 		// }
				g.Error()
			}).
			BlockFunc(func(g *jen.Group) {
				g.Var().Id("output").Qual(string(method.Output.GoIdent.GoImportPath), method.Output.GoIdent.GoName)

				g.Id("err").Op(":=").Id("f").Dot("Get").CallFunc(func(g *jen.Group) {
					g.Id("ctx")
					g.Op("&").Id("output")
				})
				g.Return().Op("&").Id("output").Op(",").Id("err")
			})

		f.Func().
			ParamsFunc(func(g *jen.Group) {
				g.Id("c").Op("*").Id(structName)
			}).
			Id(startMethodName).
			ParamsFunc(func(g *jen.Group) {
				g.Id("ctx").Qual(workflowPkg, "Context")
				// if hasInput {
				g.Id("input").Op("*").Qual(string(method.Input.GoIdent.GoImportPath), method.Input.GoIdent.GoName)
				// }
				g.Id("options").Qual(workflowPkg, "NexusOperationOptions")
			}).
			Id(futureName).
			BlockFunc(func(g *jen.Group) {
				g.Id("fut").Op(":=").Id("c").Dot("client").Dot("ExecuteOperation").
					CallFunc(func(g *jen.Group) {
						g.Id("ctx")
						g.Id(operationNameConst)
						// if hasInput {
						g.Id("input")
						// }
						g.Id("options")
					})
				g.Return().Id(futureName).BlockFunc(func(g *jen.Group) {
					g.Id("fut").Op(",")
				})
			})

		f.Func().
			ParamsFunc(func(g *jen.Group) {
				g.Id("c").Op("*").Id(structName)
			}).
			Id(executeMethodName).
			ParamsFunc(func(g *jen.Group) {
				g.Id("ctx").Qual(workflowPkg, "Context")
				// if hasInput {
				g.Id("input").Op("*").Qual(string(method.Input.GoIdent.GoImportPath), method.Input.GoIdent.GoName)
				// }
				g.Id("options").Qual(workflowPkg, "NexusOperationOptions")
			}).
			ParamsFunc(func(g *jen.Group) {
				// if hasOutput {
				g.Op("*").Qual(string(method.Output.GoIdent.GoImportPath), method.Output.GoIdent.GoName)
				// }
				g.Error()
			}).
			BlockFunc(func(g *jen.Group) {
				g.Var().Id("output").Qual(string(method.Output.GoIdent.GoImportPath), method.Output.GoIdent.GoName)

				g.Id("fut").Op(":=").Id("c").Dot("client").Dot("ExecuteOperation").
					CallFunc(func(g *jen.Group) {
						g.Id("ctx")
						g.Id(operationNameConst)
						// if hasInput {
						g.Id("input")
						// }
						g.Id("options")
					})
				g.Id("err").Op(":=").Id("fut").Dot("Get").CallFunc(func(g *jen.Group) {
					g.Id("ctx")
					g.Op("&").Id("output")
				})
				g.Return().Op("&").Id("output").Op(",").Id("err")
			})
	}
}
